<!DOCTYPE html!>
<head>

            <title>Building a CardDAV client - sabre/dav</title>
    
    <link rel="stylesheet" type="text/css" href="/css/sabredav.css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:100,700,300,400" type="text/css">
    <link rel="stylesheet" href="/components/highlightjs/styles/github.css" type="text/css" />

    <link rel="shortcut icon" href="/favicon.ico" />

</head>
<body>
    <header>

    <div class="logo">
        <a href="/">
            <img src="/img/logo.png" alt="SabreDAV. A WebDAV framework for PHP.">
            SabreDAV wiki
        </a>
    </div>

    <nav>
        <ul>
            <li><a href="/">sabre/dav</a></li>
            <li><a href="/">sabre/event</a></li>
            <li><a href="/">sabre/http</a></li>
            <li><a href="/">sabre/vobject</a></li>
        </ul>
    </nav>

</header>

    <main>
        <aside>
    <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/dav/install">Installation</a></li>
        <li><a href="/dav/upgrading">Upgrading</a></li>
        <li><a href="/dav/gettingstarted">Getting Started</a></li>
        <li>
            Troubleshooting
            <ul>
                <li><a href="/dav/faq">FAQ</a></li>
                <li><a href="/dav/clients">Clients</a></li>
                <li><a href="/dav/webservers">Webservers</a></li>
            </ul>
        </li>
        <li>
            CalDAV
            <ul>
                <li><a href="/dav/caldav">Getting started</a></li>
                <li><a href="/dav/building-a-caldav-client">Building a CalDAV client</a></li>
                <li><a href="/dav/caldav-carddav-integration-guide">Integration guide</a></li>
                <li><a href="/dav/caldav-proxy">Delegation</a></li>
                <li><a href="/dav/caldav-sharing">Calendar sharing</a></li>
                <li><a href="/dav/ics-export-plugin">iCalendar export</a></li>
                <li><a href="/dav/imiphandler">iMip Handler</a></li>
                <li><a href="/dav/service-discovery">Service Discovery</a></li>
            </ul>
        </li>
        <li>
            CardDAV
            <ul>
                <li><a href="/dav/carddav">Getting started</a></li>
                <li><a href="/dav/building-a-carddav-client">Building a CardDAV client</a></li>
                <li><a href="/dav/caldav-carddav-integration-guide">Integration guide</a></li>
                <li><a href="/dav/carddav-directory">CardDAV Directory</a></li>
                <li><a href="/dav/vcf-export-plugin">vCard export</a></li>
                <li><a href="/dav/service-discovery">Service Discovery</a></li>
            </ul>
        </li>
        <li>
            Other topics
            <ul>
                <li><a href="/dav/acl">Acl</a></li>
                <li><a href="/dav/authentication">Authentication</a></li>
                <li><a href="/dav/character-encoding">Character encoding</a></li>
                <li><a href="/dav/browser-plugin">Directory indexes</a></li>
                <li><a href="/dav/davmount">DavMount</a></li>
                <li><a href="/dav/guesscontenttype">Content Types</a></li>
                <li><a href="/dav/http-patch">PATCH support</a></li>
                <li><a href="/dav/large-files">Large files</a></li>
                <li><a href="/license">License</a></li>
                <li><a href="/dav/litmus">Litmus</a></li>
                <li><a href="/dav/plugins">Plugins</a></li>
                <li><a href="/dav/scalability">Scalability</a></li>
                <li><a href="/dav/simplecollection">SimpleCollection</a></li>
                <li><a href="/dav/standards-support">Standards Support</a></li>
                <li><a href="/dav/temporary-files">Temporary Files</a></li>
                <li><a href="/dav/versioning">Versioning</a></li>
                <li><a href="/dav/virtual-filesystems">Virtual filesystems</a></li>
                <li><a href="/dav/davclient">WebDAV Client</a></li>
                <li><a href="/dav/xmlelements">XML Elements</a></li>
                <li><a href="/dav/large-files">Large files</a></li>
                <li><a href="/dav/writing-plugins">Writing Plugins</a></li>
            </ul>
        </li>
    </ul>
</aside>
        <article>
                        <h1>Building a CardDAV client</h1>            <h2>What is this document?</h2>

<p>As server developers, we get a lot of questions on how to interact with a
CardDAV server. This document explains how to integrate correctly with a
CardDAV server.</p>

<p>This document (should) apply for <em>any</em> CardDAV server, not just SabreDAV.</p>

<h2>Clients</h2>

<p>Before you build your own client, there's a chance there's already a client
avaible for your programming language.</p>

<p>We've developed a PHP client that does <em>some</em> DAV-related stuff and makes it
a tad easier. More information can be found <a href="/dav/davclient">on this wiki</a>.</p>

<p>We'd love to have a list here for CardDAV clients. So know one?
<a href="/contact">contact</a> us.</p>

<h2>High-level protocol</h2>

<p>CardDAV is defined by <a href="https://tools.ietf.org/html/rfc6352">rfc6352</a>. CardDAV is heavily inspired by it's
counterpart CalDAV, and is mostly regarded as simpler.</p>

<p>CardDAV builds on <a href="https://tools.ietf.org/html/rfc4918">WebDAV</a>. WebDAV itself extends HTTP.</p>

<p>Some operations will be very familiar if you already have experience with HTTP
services (<code>GET</code>, <code>PUT</code> and <code>DELETE</code>), but a number of new methods have been
added to this list (<code>PROPFIND</code>, <code>PROPPATCH</code>, <code>REPORT</code>, <code>MKCOL</code>, <code>MKCALENDAR</code>,
<code>ACL</code>).</p>

<p>Most HTTP clients should just supports methods they don't know about. So it's
very wise to simply use a stock HTTP client for your platform, if your
platform does not already have a CardDAV client.</p>

<h2>vCards</h2>

<p>Every contact is submitted as a vCard. Every compliant CardDAV client or
Server <em>must</em> support vCard 3.0 (<a href="https://tools.ietf.org/html/rfc2425">rfc2425</a> and <a href="https://tools.ietf.org/html/rfc2426">rfc2426</a>).
vCard 2.1 is way too old and should always be rejected.</p>

<p>vCard 4.0 (<a href="https://tools.ietf.org/html/rfc6350">rfc6350</a>) also exists though, and is in many respects a
massive improvement over vCard 3.0. vCard 4 must now always be encoded as
UTF-8, and many inconsistencies and problems have been fixed.</p>

<p>However, compliant servers must specifically advertise that they support
vCard 4.0, and clients must be willing to send vCard 3.0 if the server does
not support it.</p>

<p>The current SabreDAV server does not yet support vCard 4. In a future release
we will want to start accepting vCard 4, and automatically convert between
vCard 3 and 4. As soon as SabreDAV does this, vCard 4 will also immediately
become the preferred format.</p>

<p>One thing we specifically want to warn people for, is that even though the
vCard format seems easy to parse and generate, there are a lot of little rules
that make it complicated.</p>

<p>A simple vCard may look like this:</p>

<pre><code>BEGIN:VCARD
VERSION:4.0
FN:Evert Pot
N:Pot;Evert;;;
END:VCARD
</code></pre>

<p>Don't fall into the trap of thinking every line is simply in the format
<code>propertyname colon propertyvalue</code>.</p>

<p>There's:</p>

<ul>
<li>Mixed character encoding, sometimes differing per line</li>
<li>Different escaping mechanisms of values, which depends on the <em>name</em> of the
value.</li>
<li>Parameters, with different escaping mechanisms and a new (rfc6868) standard
escaping mechanism that noone supports yet.</li>
<li>Line-folding. Sometimes single multi-byte UTF-8 characters are split up with
a new-line.</li>
<li>Two styles of new-lines, sometimes in the same document (<code>\n</code> and <code>\r\n</code>).</li>
<li>Quoted-printable encoding and base64 encoding.</li>
<li>Parameters that have their name omitted, because it's implied from their
values.</li>
<li>Properties can be grouped together with a special syntax that alters the
encoding of a property group.</li>
</ul>

<p>Why did I write this list? Because if you're going to parse and generate
vCards, you should either:</p>

<ul>
<li>Be fully aware of the scope of doing so, or:</li>
<li>Use a parser that somebody already wrote for your programming language.</li>
</ul>

<h3>vCard parsers, per language</h3>

<table>
<thead>
<tr>
  <th>Language</th>
  <th>Library</th>
</tr>
</thead>
<tbody>
<tr>
  <td>PHP</td>
  <td><a href="https://packagist.org/packages/sabre/vobject">sabre/vobject</a></td>
</tr>
<tr>
  <td>Java</td>
  <td><a href="https://code.google.com/p/ez-vcard/">ez-vcard</a></td>
</tr>
<tr>
  <td>Ruby</td>
  <td><a href="http://rubygems.org/gems/vcard">vcard</a></td>
</tr>
</tbody>
</table>

<p>Know of any other good vCard parsers? Let me know so I can list them.</p>

<h2>XML</h2>

<p>CardDAV servers also use XML for various things:</p>

<ul>
<li>Getting a list of all vCards</li>
<li>Getting information about an addressbook</li>
<li>Finding out if vCards or addressbooks have changed.</li>
</ul>

<h2>Retain full vCards!</h2>

<p>Normally when integrating with new api's, you will figure out the data
available, and write code to map that data to a local data model. This is true
if the webservice is xml-based, restful or, dare I say it, SOAP.</p>

<p>The problem with simply 'mapping' remote information, in this case, things
like addresses, telephone numbers, first names, photos, etc, is that there
are a <em>lot</em> of things to map.</p>

<p>What if your data model does not support a fax number? vCards can have a <em>lot</em>
of different information, and information about information.</p>

<p>If we look at the protocol from a very high level, we will do a <code>GET</code> to
receive a vCard, and a <code>PUT</code> to update it again.</p>

<p>You <em>must</em> make sure that none of the information you received in a <code>GET</code>
is lost when you perform the <code>PUT</code>.</p>

<p>Almost every client on the planet will even embed custom non-standard data
in vCards. If you discard this data when performing <code>PUT</code>, you are destroying
your users data.</p>

<p>So a common trick that implementors use <strong>AND WE DON'T RECOMMEND</strong> is</p>

<ol>
<li>Go through all the properties of a vCard</li>
<li>Map the properties you support to a local data model</li>
<li>Keep the properties you don't support separately.</li>
</ol>

<p>Then when the vCard is uploaded again with <code>PUT</code>, the 'unknown' properties
are stitched back in.</p>

<p>We consider this to be a bad idea, because it ignores several vCard features:</p>

<ul>
<li>Parameters you may or may not support</li>
<li>Property groups</li>
<li>And a little bit less important: the order in which items appear can be
relevant to the user.</li>
</ul>

<h3>What we recommend</h3>

<ol>
<li>Download the vCard</li>
<li>Retain the entire vCard and store it locally, or at least in some
lossless way</li>
<li>Parse the vCard and populate your models with the information that is
relevant to you.</li>
<li>Keep a reference to which vCard property maps to what information in the
model.</li>
</ol>

<p>Now when something changes in a model (e.g.: a user changes an email address)</p>

<ol>
<li>Model receives change (email address updated)</li>
<li>Find the property in the vCard that originally mapped to the information in
the model.</li>
<li>Update the value in the vCard.</li>
<li>Upload the vCard.</li>
</ol>

<p>In an ideal world, your vCard <em>is</em> your model though.</p>

<p>Regardless of how this issue is solved (there may be better suggestions, we
would love to hear it), <em>not</em> ensuring that original vCard is kept as close
to the original as possible is guaranteed to trigger bugs and edge-cases for
all sorts of CardDAV clients.</p>

<p><strong>End of rant.. sorry about that</strong></p>

<h2>Typical urls</h2>

<p>Note that the following url structure is typical for SabreDAV, but may be
different for other servers. All these urls should be discovered by a client,
but listing these here helps with illustrating the examples that follow:</p>

<table>
<thead>
<tr>
  <th>url</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>http://dav.example.org/</code></td>
  <td>Root</td>
</tr>
<tr>
  <td><code>http://dav.example.org/principals/johndoe/</code></td>
  <td>A principal url</td>
</tr>
<tr>
  <td><code>http://dav.example.org/addressbooks/johndoe/</code></td>
  <td>The addressbook home</td>
</tr>
<tr>
  <td><code>http://dav.example.org/addressbooks/johndoe/contacts/</code></td>
  <td>An addressbook</td>
</tr>
<tr>
  <td><code>http://dav.example.org/addressbooks/johndoe/contacts/foobarapp-2357-aeaat34.vcf</code></td>
  <td>A vcard</td>
</tr>
</tbody>
</table>

<h2>Authentication</h2>

<p>Servers typically use HTTP Digest or HTTP Basic authentication. Your client
should already support these. The Google CardDAV API uses OAuth2.</p>

<h2>Operations</h2>

<h3>Retrieving addressbook information</h3>

<p>To receive information about a URL, we use the <code>PROPFIND</code> method.
In this case we're going to ask for the addressbooks display name and a
so-called 'ctag'.</p>

<pre><code>PROPFIND /addressbooks/johndoe/contacts/ HTTP/1.1
Depth: 0
Prefer: return-minimal
Content-Type: application/xml; charset=utf-8

&lt;d:propfind xmlns:d="DAV:" xmlns:cs="http://calendarserver.org/ns/"&gt;
  &lt;d:prop&gt;
     &lt;d:displayname /&gt;
     &lt;cs:getctag /&gt;
  &lt;/d:prop&gt;
&lt;/d:propfind&gt;
</code></pre>

<p>The <code>PROPFIND</code> request is a HTTP request, defined by <a href="https://tools.ietf.org/html/rfc4918">WebDAV</a>.
<code>PROPFIND</code> allows the client to fetch properties from an url.</p>

<p>CardDAV uses many properties like this, but in this case we just fetch the
'displayname', which is the human-readable name the user gave the addressbook, and
the ctag. The ctag must be stored for subsequent requests.</p>

<p>The request will return something like:</p>

<pre><code>HTTP/1.1 207 Multi-status
Content-Type: application/xml; charset=utf-8

&lt;d:multistatus xmlns:d="DAV:" xmlns:cs="http://calendarserver.org/ns/"&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/addressbooks/johndoe/contacts/&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;d:displayname&gt;My Address Book&lt;/d:displayname&gt;
                &lt;cs:getctag&gt;3145&lt;/cs:getctag&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
&lt;/d:multistatus&gt;
</code></pre>

<p>This multistatus response is very common for Cal and WebDAV. Many requests
return an xml document in this exact format, so it is worthwhile writing a
standard parser.</p>

<p>The response gives us back the user, the values for the 2 properties and the
status.</p>

<p>It is possible that a server does not support the ctag. In that case it will
likely return <code>404 Not Found</code> for the ctag, and <code>200 OK</code> for the displayname.</p>

<p>Example:</p>

<pre><code>HTTP/1.1 207 Multi-status
Content-Type: application/xml; charset=utf-8

&lt;d:multistatus xmlns:d="DAV:" xmlns:cs="http://calendarserver.org/ns/"&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/addressbooks/johndoe/contacts/&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;d:displayname&gt;My Address Book&lt;/d:displayname&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;cs:getctag&gt;3145&lt;/cs:getctag&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 404 Not Found&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
&lt;/d:multistatus&gt;
</code></pre>

<p>So take note from this last response. Here we display that the status, such
as the <code>404</code> and the <code>200</code> are <em>not</em> related to the existence of the url
(<code>/addressbooks/johndoe/contacts</code>). The statuscodes are re-used to return
infromation about the individual properties.</p>

<h3>Downloading objects</h3>

<p>Now we download every single object in this addressbook. To do this, we use a
<code>REPORT</code> method.</p>

<pre><code>REPORT /addressbooks/johndoe/contacts/ HTTP/1.1
Depth: 1
Prefer: return-minimal
Content-Type: application/xml; charset=utf-8

&lt;card:addressbook-query xmlns:d="DAV:" xmlns:card="urn:ietf:params:xml:ns:carddav"&gt;
    &lt;d:prop&gt;
        &lt;d:getetag /&gt;
        &lt;card:address-data /&gt;
    &lt;/d:prop&gt;
&lt;/c:addressbook-query&gt;
</code></pre>

<p>This request will return a large xml object with <em>all</em> the vCards, and their
etags.</p>

<p>This report will return a multi-status object again:</p>

<pre><code>HTTP/1.1 207 Multi-status
Content-Type: application/xml; charset=utf-8

&lt;d:multistatus xmlns:d="DAV:" xmlns:card="urn:ietf:params:xml:ns:carddav"&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/addressbooks/johndoe/contacts/abc-def-fez-123454657.vcf&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;d:getetag&gt;"2134-314"&lt;/d:getetag&gt;
                &lt;card:address-data&gt;BEGIN:VCARD
                    VERSION:3.0
                    FN:My Mother
                    UID:abc-def-fez-1234546578
                    END:VCARD
                &lt;/card:address-data&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/addressbooks/johndoe/contacts/someapplication-12345678.vcf&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;d:getetag&gt;"5467-323"&lt;/d:getetag&gt;
                &lt;card:address-data&gt;BEGIN:VCARD
                    VERSION:3.0
                    FN:Your Mother
                    UID:foo-bar-zim-gir-1234567
                    END:VCARD
                &lt;/card:address-data&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
&lt;/d:multistatus&gt;
</code></pre>

<p>This addressbook only contained 2 contacts.</p>

<p>So after you retrieved and processed these, for each object you must retain:</p>

<ul>
<li>The vCard data itself</li>
<li>The url</li>
<li>The etag</li>
</ul>

<p>In this case all urls ended with <code>.vcf</code>. This is often the case, buy you must
not rely on this. In this case the UID in the vCards was also identical to
a part of the url. This too is often the case, but again not something you can
rely on, so don't make any assumptions.</p>

<p>The url and the UID have no meaningful relationship, so treat both those items
as separate unique identifiers.</p>

<h3>Finding out if anything changed</h3>

<p>To see if anything in an addressbook changed, we simply request the ctag again
on the addressbook. If the ctag did not change, you still have the latest copy.</p>

<p>This is the purpose of the ctag. Every time <em>anything</em> in the address book
changes, the ctag must also change.</p>

<p>If it did change, you should request all the etags in the entire addressbook
again:</p>

<pre><code>REPORT /addressbooks/johndoe/contacts/ HTTP/1.1
Depth: 1
Prefer: return-minimal
Content-Type: application/xml; charset=utf-8

&lt;card:addressbook-query xmlns:d="DAV:" xmlns:card="urn:ietf:params:xml:ns:carddav"&gt;
    &lt;d:prop&gt;
        &lt;d:getetag /&gt;
    &lt;/d:prop&gt;
&lt;/c:addressbook-query&gt;
</code></pre>

<p>Note that this last request is extremely similar to a previous one, but we are
only asking for the etag, not the address-data.</p>

<p>The reason for this, is that addressbooks can be rather huge. It will save a TON
of bandwidth to only check the etag first.</p>

<pre><code>HTTP/1.1 207 Multi-status
Content-Type: application/xml; charset=utf-8

&lt;d:multistatus xmlns:d="DAV:" xmlns:card="urn:ietf:params:xml:ns:carddav"&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/addressbooks/johndoe/contacts/abc-def-fez-123454657.vcf&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;d:getetag&gt;"2134-888"&lt;/d:getetag&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/addressbooks/johndoe/contacts/acme-12345.vcf&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;d:getetag&gt;"9999-2344""&lt;/d:getetag&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
&lt;/d:multistatus&gt;
</code></pre>

<p>Judging from this last request, 3 things have changed:</p>

<ul>
<li>The etag for the first contact has changed, so it must have been updated.</li>
<li>There's a new url, some other client must have created a new contact.</li>
<li>The second contact we saw earlier is no longer in the list, so it must have
been deleted.</li>
</ul>

<p>So based on those 3 points, we know that we need to remove a contact from the
local addressbook, and fetch the vCards for both the new item, and the updated
one.</p>

<p>To fetch the data for these, you can simply issue GET requests:</p>

<pre><code>GET /addressbooks/johndoe/contacts/abc-def-fez-123454657.vcf
</code></pre>

<p>But that does not scale up well, in case a few hundred contacts have changed.
It's better to batch the GET's together with <code>multiget</code>.</p>

<pre><code>REPORT /addressbooks/johndoe/contacts/ HTTP/1.1
Depth: 1
Prefer: return-minimal
Content-Type: application/xml; charset=utf-8

&lt;card:addressbook-multiget xmlns:d="DAV:" xmlns:card="urn:ietf:params:xml:ns:carddav"&gt;
    &lt;d:prop&gt;
        &lt;d:getetag /&gt;
        &lt;c:addressbook-data /&gt;
    &lt;/d:prop&gt;
    &lt;d:href&gt;/addressbooks/johndoe/contacts/abc-def-fez-123454657.vcf&lt;/d:href&gt;
    &lt;d:href&gt;/addressbooks/johndoe/contacts/acme-12345.vcf&lt;/d:href&gt;
&lt;/card:addressbook-multiget&gt;
</code></pre>

<p>This request will simply return a multi-status again with the addressbook-data and
etag.</p>

<h3>A small note about writing code for this.</h3>

<p>If you read this far and understood what's been said, you may have realized that
it's a bit cumbersome to have a separate step for the initial sync, and
subsequent updates.</p>

<p>It would totally be possible to skip the 'initial sync', and just use
addressbook-query and addressbook-multiget REPORTS for the initial sync as well.</p>

<h2>Updating a contact</h2>

<p>Updating a vCard is rather simple:</p>

<pre><code>PUT /addressbook/johndoe/contacts/some-contact.vcf HTTP/1.1
Content-Type: text/vcard; charset=utf-8
If-Match: "2134-314"

BEGIN:VCARD
....
END:VCARD
</code></pre>

<p>A response to this will be something like this:</p>

<pre><code>HTTP/1.1 204 No Content
ETag: "2134-315"
</code></pre>

<p>The update gave us back the new ETag. SabreDAV returns this ETag on updates
most of the time, but not always.</p>

<p>There are cases where the CarddAV server must modify the vCard immediatly
after receiving it, for various reasons. In those situations an ETag will
<em>not</em> be returned, and you should ideally issue a GET request immediately
after to figure out how the server changed the contact.</p>

<p>Many clients skip the <code>GET</code> step though.</p>

<p>A few notes:</p>

<h3>Don't change the UID</h3>

<p>The <code>UID</code> and the url of the object are important to not change. Changing
either will highly confuse other clients and the server <em>should</em> reject those
changes (although they don't always).</p>

<h2>Creating a contact</h2>

<p>Creating a contact is almost identical, except that you (as a client) are
responsible for determining the url of the object, and UID.</p>

<pre><code>PUT /addressbooks/johndoe/contacts/somerandomstring.vcf HTTP/1.1
Content-Type: text/vcard; charset=utf-8

BEGIN:VCARD
VERSION:3.0
UID:some-other-random-string
....
END:VCARD
</code></pre>

<p>A response to this will be something like this:</p>

<pre><code>HTTP/1.1 201 Created
ETag: "21345-324"
</code></pre>

<p>Similar to updating, an ETag is often returned, but there are cases where this
is not true.</p>

<h2>Deleting a contact</h2>

<p>Deleting is simple enough:</p>

<pre><code>DELETE /addressbooks/johndoe/contacts/132456762153245.vcf HTTP/1.1
If-Match: "2134-314"
</code></pre>

<h2>Discovery</h2>

<p>Ideally you will want to make sure that all the addressbooks in an account are
automatically discovered. The best user interface would be to just have to
ask for three items:</p>

<ul>
<li>Username</li>
<li>Password</li>
<li>Server</li>
</ul>

<p>And the server should be as short as possible. This is possible with most
servers.</p>

<p>If, for example a user specified 'dav.example.org' for the server, the first
thing you should do is attempt to send a <code>PROPFIND</code> request to
<code>https://dav.example.org/</code>. Note that you <em>should</em> try the https url before the
http url.</p>

<p>This <code>PROPFIND</code> request looks as follows:</p>

<pre><code>PROPFIND / HTTP/1.1
Depth: 0
Prefer: return-minimal
Content-Type: application/xml; charset=utf-8

&lt;d:propfind xmlns:d="DAV:"&gt;
  &lt;d:prop&gt;
     &lt;d:current-user-principal /&gt;
  &lt;/d:prop&gt;
&lt;/d:propfind&gt;
</code></pre>

<p>This will return a response such as the following:</p>

<pre><code>HTTP/1.1 207 Multi-status
Content-Type: application/xml; charset=utf-8

&lt;d:multistatus xmlns:d="DAV:"&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;d:current-user-principal&gt;
                    &lt;d:href&gt;/principals/users/johndoe/&lt;/d:href&gt;
                &lt;/d:current-user-principal&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
&lt;/d:multistatus&gt;
</code></pre>

<p>A 'principal' is a user. The url that's being returned, is a url that refers
to the current user. On this url you can request additional information about
the user.</p>

<p>What we need from this url, is their 'addressbook home'. The addressbook home
is a collection that contains all of the users' addressbooks.</p>

<p>To request that, issue the following request:</p>

<pre><code>PROPFIND /principals/users/johndoe/ HTTP/1.1
Depth: 0
Prefer: return-minimal
Content-Type: application/xml; charset=utf-8

&lt;d:propfind xmlns:d="DAV:" xmlns:card="urn:ietf:params:xml:ns:carddav"&gt;
  &lt;d:prop&gt;
     &lt;card:addressbook-home-set /&gt;
  &lt;/d:prop&gt;
&lt;/d:propfind&gt;
</code></pre>

<p>This will return a response such as the following:</p>

<pre><code>HTTP/1.1 207 Multi-status
Content-Type: application/xml; charset=utf-8

&lt;d:multistatus xmlns:d="DAV:" xmlns:card="urn:ietf:params:xml:ns:carddav"&gt;
    &lt;d:response&gt;
        &lt;d:href&gt;/&lt;/d:href&gt;
        &lt;d:propstat&gt;
            &lt;d:prop&gt;
                &lt;c:addressbook-home-set&gt;
                    &lt;d:href&gt;/addressbooks/johndoe/&lt;/d:href&gt;
                &lt;/c:addressbook-home-set&gt;
            &lt;/d:prop&gt;
            &lt;d:status&gt;HTTP/1.1 200 OK&lt;/d:status&gt;
        &lt;/d:propstat&gt;
    &lt;/d:response&gt;
&lt;/d:multistatus&gt;
</code></pre>

<p>Lastly, to list all the addressbooks for the user, issue a PROPFIND request
with <code>Depth: 1</code>.</p>

<pre><code>PROPFIND /addressbooks/johndoe/ HTTP/1.1
Depth: 1
Prefer: return-minimal
Content-Type: application/xml; charset=utf-8

&lt;d:propfind xmlns:d="DAV:" xmlns:cs="http://calendarserver.org/ns/"&gt;
  &lt;d:prop&gt;
     &lt;d:resourcetype /&gt;
     &lt;d:displayname /&gt;
     &lt;cs:getctag /&gt;
  &lt;/d:prop&gt;
&lt;/d:propfind&gt;
</code></pre>

<p>In that last request, we asked for 3 properties.</p>

<p>The <code>resourcetype</code> tells us what type of object we're getting back. You must
read out the <code>resourcetype</code> and ensure that it contains at least an
<code>addressbook</code> element in the CardDAV namespace. Other items <em>may</em> be returned,
including non-addressbooks, which your application should ignore.</p>

<h3>Advanced discovery topics</h3>

<p>Read the <a href="/dav/service-discovery">Service Discovery documentation</a></p>
                    </article>
    </main>

    <script src="/components/highlightjs/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-2848664-5', 'sabredav.org');
ga('send', 'pageview');
</script>

    
</body>
